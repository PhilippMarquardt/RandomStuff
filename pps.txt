import json
from typing import Any, Dict, List, Union

def is_data_collection(d: Dict) -> bool:
    """
    Heuristic to determine if a dictionary is a 'Collection of Rows' 
    (where we should truncate output) vs a 'Structural Node' (where we show all keys).
    
    Criteria for being a Collection:
    1. Must be a dictionary of dictionaries (e.g. { "id1": {...}, "id2": {...} })
    2. Keys look like IDs (numeric or short strings) 
       OR 
       Entries are homogeneous (share same schema keys).
    """
    if not d: return False
    
    keys = list(d.keys())
    if not keys: return False
    
    # 1. Check Content Type: Values must be Dictionaries (Rows)
    # Sampling the first item is usually sufficient
    first_val = d[keys[0]]
    if not isinstance(first_val, dict):
        return False
        
    # 2. Check Key Pattern (Strongest Signal)
    # If keys are numeric strings ("0", "160046", "1.0"), it's definitely a collection.
    numeric_keys = sum(1 for k in keys if str(k).replace('.', '', 1).isdigit())
    if len(keys) > 0 and (numeric_keys / len(keys)) > 0.5:
        return True
        
    # 3. Check Homogeneity (Secondary Signal for non-numeric IDs like "uuid-1", "uuid-2")
    # If we have multiple items, check if they look like the same "type" of record.
    if len(keys) > 1:
        row_1_keys = set(d[keys[0]].keys())
        row_2_keys = set(d[keys[1]].keys())
        
        # Jaccard Index: If rows share > 50% of their field names, it's a collection.
        intersection = len(row_1_keys.intersection(row_2_keys))
        union = len(row_1_keys.union(row_2_keys))
        
        if union > 0 and (intersection / union) > 0.5:
            return True
            
    return False

def print_dict_structure(d: Any, indent: int = 0, parent_key: str = "root"):
    """
    Recursively prints the structure of a dictionary/list.
    Uses dynamic detection to avoid spamming large data collections.
    """
    spacing = "  " * indent
    type_name = type(d).__name__
    
    # 1. Handle Dictionaries
    if isinstance(d, dict):
        keys = list(d.keys())
        count = len(keys)
        print(f"{spacing}{parent_key}: {type_name} [{count} keys]")
        
        # --- DYNAMIC DETECTION ---
        # Check if this dictionary is a "Collection of Rows" or a "Structural Container"
        is_collection = is_data_collection(d)
        
        for i, key in enumerate(keys):
            # Smart Truncation: If it's a collection, only show the first item schema
            if is_collection and i >= 1:
                print(f"{spacing}  ... (+ {count - 1} more items in '{parent_key}')")
                break
            
            # Recurse
            print_dict_structure(d[key], indent + 1, parent_key=str(key))

    # 2. Handle Lists
    elif isinstance(d, list):
        count = len(d)
        print(f"{parent_key}: {type_name} [{count} items]")
        
        if count > 0:
            print(f"{spacing}  - [0]: ", end="")
            print_dict_structure(d[0], indent + 1, parent_key=f"{parent_key}[0]")
            if count > 1:
                print(f"{spacing}  ... (+ {count - 1} more items)")
    
    # 3. Handle Leaf Nodes
    else:
        preview = str(d)
        if len(preview) > 50:
            preview = preview[:50] + "..."
        print(f"({type_name}) -> {preview}")

# ==========================================
# TEST RUNNER (Using a simulation of your full JSON structure)
# ==========================================
if __name__ == "__main__":
    # Mock data with dynamic, nested structure
    mock_data = {
        "perspective_configurations": {
            # This is a structural node, keys are IDs but contents are different (list vs dict)
            "404294674": { "14": ["exclude_stuff"] },
            "404294675": { "50": {"key": "value"} }
        },
        "holding": {
            # Structural node
            "positions": {
                # Collection (Numeric Keys)
                "160046": { "instrument_identifier": 1, "weight": 1.0, "initial_weight": 0.5 },
                "160047": { "instrument_identifier": 2, "weight": 1.0, "initial_weight": 0.5 }
            },
            "complete_lookthroughs": {
                # Collection (Numeric Keys)
                "0": { "parent_id": 1, "lt_weight": 0.1, "initial_weight": 0.1 },
                "1": { "parent_id": 1, "lt_weight": 0.2, "initial_weight": 0.2 }
            }
        },
        "contractual_reference_dynamic": {
             # Structural node
             "positions": {
                 # Collection (Arbitrary String Keys, but homogeneous schema)
                 "row_a": {"id": 10, "val": 100},
                 "row_b": {"id": 11, "val": 200}
             }
        },
        "system_version_timestamp": "2025-11-20 12:44:00.000000"
    }

    print("--- DYNAMIC STRUCTURE ANALYSIS ---")
    print("This confirms the parser can handle any amount of reference containers.")
    print("-" * 35)
    print_dict_structure(mock_data)