def apply_perspective_rules(self, rules, perspective_id, additional_rule_data: dict = None, are_filtering_rules: bool = True, post_processing_modifiers: dict = None, scale_holdings_to_100_percent: bool = False, rescale_lookthroughs_to_100_percent_modifier = None):
        """ Applies the rules to the data """

        datasets_for_rule_application = {}

        if additional_rule_data:
            for rule in rules:
                for table in [t for t in rule.required_columns if t != 'position_data' and t in additional_rule_data]:
                    datasets_for_rule_application[table] = additional_rule_data[table]

            if rescale_lookthroughs_to_100_percent_modifier and not rescale_lookthroughs_to_100_percent_modifier.rule.criteria.tablename in datasets_for_rule_application:
                datasets_for_rule_application[table] = additional_rule_data[table]

        if self.positions is not None and not self.positions.empty:
            # FIX 1: Create a SHALLOW COPY for the Position Run. 
            # This isolates the dictionary so any keys added here don't leak to lookthroughs.
            position_run_data = datasets_for_rule_application.copy()
            position_run_data['position_data'] = self.positions

            start_time = perf_counter()
            self._apply_perspective_rules(rules, self.position_weight_labels, perspective_id, position_run_data, are_filtering_rules, post_processing_modifiers=post_processing_modifiers, scale_holdings_to_100_percent=scale_holdings_to_100_percent, rescale_lookthroughs_to_100_percent_modifier=rescale_lookthroughs_to_100_percent_modifier)
            self._add_metric_entry('applying perspective {0}rules to \'{1}\' positions'.format('scaling ' if not are_filtering_rules else '', self._container_name), start_time, perf_counter())
        
        if self.lookthroughs:
            if rescale_lookthroughs_to_100_percent_modifier:
                for table in [t for t in rescale_lookthroughs_to_100_percent_modifier.rule.required_columns if t != 'position_data' and t in additional_rule_data]:
                    datasets_for_rule_application[table] = additional_rule_data[table]

            for lookthrough in [lt for lt in self.lookthroughs if self.lookthroughs[lt] is not None and not self.lookthroughs[lt].empty]:
                # FIX 2: Create a SHALLOW COPY for the Lookthrough Run.
                # This ensures we start with a clean state, ignoring anything the Position run did.
                lookthrough_run_data = datasets_for_rule_application.copy()
                lookthrough_run_data['position_data'] = self.lookthroughs[lookthrough]

                start_time = perf_counter()
                self._apply_perspective_rules(rules, self.lookthrough_weight_labels, perspective_id, lookthrough_run_data, are_filtering_rules, post_processing_modifiers, lookthrough, rescale_lookthroughs_to_100_percent_modifier=rescale_lookthroughs_to_100_percent_modifier)
                self._add_metric_entry('applying perspective {0}rules to \'{1}\' lookthrough \'{2}\''.format('scaling ' if not are_filtering_rules else '', self._container_name, lookthrough), start_time, perf_counter())



def _apply_perspective_rules(self, rules, weight_labels: list, perspective_id: int, rule_application_data: dict = None, are_filtering_rules: bool = True, post_processing_modifiers: dict = None, lookthrough_name: str = None, scale_holdings_to_100_percent = None, rescale_lookthroughs_to_100_percent_modifier = None):
        """ Applies the rules for the perspective for the given "position type" ie. holding / reference """

        metric_dict = {}
        scaling_result_label = 'scaling_result'
        
        if not isinstance(rules, list):
            rules = [rules]

        try:
            # --- PHASE 1: STANDARD RULES ---
            # We iterate normally. If rules is empty, this loop is skipped safely.
            for rule in rules:
                if rule.apply_to.lower() != 'both' and rule.apply_to.lower() != self._position_data_type:
                    continue

                with trace.get_tracer(__name__).start_as_current_span('applying rules to {0}{1}'.format(self._container_name, '' if not lookthrough_name else f'({lookthrough_name})')):
                    rule_results = self._evaluate_rule_results(rule, rule_application_data, weight_labels, perspective_id, 'result' if are_filtering_rules else scaling_result_label)

                # Standard Filtering Logic for Rules
                if are_filtering_rules:
                    self._apply_filtering_logic(rule_results, lookthrough_name, scale_holdings_to_100_percent)
                
                # Standard Scaling Logic for Rules
                if rule.exposure_factor and not lookthrough_name:
                    with trace.get_tracer(__name__).start_as_current_span(f'applying scale factors for {self._container_name}'):
                        self._position_data = self._apply_exposure_factor_to_positions(rule_results, self._position_data, scaling_result_label, rule.exposure_factor, weight_labels)

            # --- PHASE 2: POST PROCESSING MODIFIERS ---
            # Now that all rules have run, we prepare the data for modifiers.
            # We construct a "Base Result" where everyone currently surviving is True.
            # This ensures modifiers run even if there were NO rules.
            
            if post_processing_modifiers:
                # Construct a clean 'result' dataframe based on the CURRENT surviving positions
                # This fixes the "broken weights" because we pull fresh data from the current position_data
                current_data = self._lookthroughs[lookthrough_name] if lookthrough_name else self._position_data
                
                # We need identifier, and potentially instrument_id/weights depending on what the modifier needs.
                # Just grabbing the identifiers is usually safest for the 'result' dataframe.
                rule_results = current_data[['identifier']].copy()
                rule_results['result'] = True
                rule_results['rule_application_results'] = 'Base Pass for Modifiers'

                # Inject into the dictionary for the modifiers to use
                rule_application_data['rule_result'] = self._merge_results_with_positions(rule_application_data['position_data'], rule_results, [])

                with trace.get_tracer(__name__).start_as_current_span('applying post processing modifiers to {0}{1}'.format(self._container_name, '' if not lookthrough_name else f'({lookthrough_name})')):
                    for post_processing_modifier in post_processing_modifiers:
                        with trace.get_tracer(__name__).start_as_current_span('applying post processing modifier {0} to {1}{2}'.format(post_processing_modifier.name, self._container_name, '' if not lookthrough_name else f'.({lookthrough_name})')):
                            
                            post_processing_modifier_results = self._evaluate_rule_results(post_processing_modifier.rule, rule_application_data, weight_labels, perspective_id, 'result')

                            # Combine the Base Pass (True) with the Modifier Result using the operator
                            # Since Base is all True, AND/OR logic works cleanly against the modifier's opinion
                            combined_results = self._stringify_results([rule_results, post_processing_modifier_results], post_processing_modifier.rule_result_operator, 'result')
                            
                            # Filter based on the modifier outcome
                            if are_filtering_rules:
                                self._apply_filtering_logic(combined_results, lookthrough_name, scale_holdings_to_100_percent, rule_application_data, rescale_lookthroughs_to_100_percent_modifier, perspective_id)

            return metric_dict
        except Exception as ex:
            raise ex

    # --- HELPER: Extracts the repetitive filtering logic to keep Phase 1 and 2 clean ---
    def _apply_filtering_logic(self, rule_results, lookthrough_name, scale_holdings_to_100_percent, rule_application_data=None, rescale_lookthroughs_to_100_percent_modifier=None, perspective_id=None):
        if not lookthrough_name:
            if self._lookthroughs:
                positions_which_failed = rule_results['identifier'][rule_results['result'] == False].values.tolist()
                if positions_which_failed:
                    parent_ids = self._positions[['instrument_id', 'sub_portfolio_id']][self._positions['identifier'].isin(positions_which_failed)].values.tolist()
                    
                    with trace.get_tracer(__name__).start_as_current_span(f'removing lookthrough positions for {self._container_name}'):
                        for lt in [k for k in self._lookthroughs if self._lookthroughs[k] is not None and not self._lookthroughs[k].empty]:
                            lt_to_remove = self._lookthroughs[lt]['identifier'][
                                self._lookthroughs[lt][['parent_instrument_id', 'sub_portfolio_id']].apply(tuple, axis=1).isin(set(map(tuple, parent_ids)))
                            ].values.tolist()
                            if lt_to_remove:
                                self._handle_removed_positions(lt_to_remove, 'removed because parent positions failed rule', 'identifier', lt)

            self._position_data = self._merge_results_with_positions(self._position_data, rule_results, self.position_weight_labels)
            if scale_holdings_to_100_percent:
                self.rescale_positions_to_100_percent()
        else:
            if self._lookthroughs[lookthrough_name] is None or self._lookthroughs[lookthrough_name].empty:
                return

            lt_to_remove = rule_results['identifier'][rule_results['result'] == False].values.tolist()
            if lt_to_remove:
                self._handle_removed_positions(lt_to_remove, 'failed the rule', 'identifier', lookthrough_name)

            if self._lookthroughs[lookthrough_name] is not None and not self._lookthroughs[lookthrough_name].empty:
                self._lookthroughs[lookthrough_name] = self._merge_results_with_positions(self._lookthroughs[lookthrough_name], rule_results, self.lookthrough_weight_labels, None, True)

                # Rescaling Logic (Only needed for Modifiers usually, but kept for safety)
                if rule_results['identifier'][rule_results['result'] == False].shape[0] > 0 and rescale_lookthroughs_to_100_percent_modifier and rule_application_data:
                    metric_name = f'rescaling \'{0}\' lookthrough \'{1}\' to 100%'
                    with trace.get_tracer(__name__).start_as_current_span(metric_name):
                        start_time = perf_counter()
                        data_sets = {table: rule_application_data[table] for table in rule_application_data.keys() if table in rescale_lookthroughs_to_100_percent_modifier.rule.required_columns}
                        self.rescale_lookthroughs_to_100_percent(lookthrough_name, data_sets, rescale_lookthroughs_to_100_percent_modifier.rule.criteria, perspective_id)
                        self._add_metric_entry(metric_name, start_time, perf_counter())